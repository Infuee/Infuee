/**
 * Minified by jsDelivr using UglifyJS v3.0.24.
 * Original file: /npm/socket.io-file-client@2.0.2/socket.io-file-client.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
"use strict";
!(function () {
    function e() {
        return o++;
    }
    function t(e, t) {
        t = t || {};
        var i = this,
            o = this.socket,
            s = this.chunkSize,
            r = (this.transmissionDelay, e.uploadId),
            n = t.uploadTo || "",
            l = t.data || {},
            a = { id: r, name: e.name, size: e.size, chunkSize: s, sent: 0, data: l };
        n && (a.uploadTo = n);
        var d = new FileReader();
        (d.onloadstart = function () {
            i.emit("loadstart");
        }),
            (d.onprogress = function (e) {
                i.emit("progress", { loaded: e.loaded, total: e.total });
            }),
            (d.onloadend = function () {
                function t() {
                    if (!a.aborted)
                        if (a.sent >= c.byteLength) o.emit("socket.io-file::done::" + r);
                        else {
                            var e = c.slice(a.sent, a.sent + s);
                            i.emit("stream", { uploadId: a.id, name: a.name, size: a.size, sent: a.sent, uploadTo: n, data: l }),
                                o.once("socket.io-file::request::" + r, t),
                                o.emit("socket.io-file::stream::" + r, e),
                                (a.sent += e.byteLength),
                                (i.uploadingFiles[r] = a);
                        }
                }
                var c = d.result;
                if (i.accepts && i.accepts.length > 0) {
                    for (var f = !1, u = 0; u < i.accepts.length; u++) {
                        var p = i.accepts[u];
                        if (e.type === p) {
                            f = !0;
                            break;
                        }
                    }
                    if (!f)
                        return i.emit("error", new Error("Not Acceptable file type " + e.type + " of " + e.name + ". Type must be one of these: " + i.accepts.join(", ")), {
                            uploadId: a.id,
                            name: a.name,
                            size: a.size,
                            type: e.type,
                            uploadTo: n,
                            data: l,
                        });
                }
                if (i.maxFileSize && i.maxFileSize > 0 && e.size > +i.maxFileSize)
                    return i.emit("error", new Error("Max Uploading File size must be under " + i.maxFileSize + " byte(s)."), { uploadId: a.id, name: a.name, size: a.size, uploadTo: n, data: l });
                (i.uploadingFiles[r] = a),
                    i.emit("start", { uploadId: a.id, name: a.name, size: a.size, uploadTo: n, data: l }),
                    o.emit("socket.io-file::createFile", a),
                    o.once("socket.io-file::request::" + r, t),
                    o.on("socket.io-file::complete::" + r, function (e) {
                        (e.uploadId = a.id),
                            (e.data = a.data),
                            o.removeAllListeners("socket.io-file::abort::" + r),
                            o.removeAllListeners("socket.io-file::error::" + r),
                            o.removeAllListeners("socket.io-file::complete::" + r),
                            delete i.uploadingFiles[r],
                            i.emit("complete", e);
                    }),
                    o.on("socket.io-file::abort::" + r, function (e) {
                        (a.aborted = !0), i.emit("abort", { uploadId: a.id, name: a.name, size: a.size, sent: a.sent, wrote: e.wrote, uploadTo: n, data: l });
                    }),
                    o.on("socket.io-file::error::" + r, function (e) {
                        i.emit("error", new Error(e.message), { uploadId: a.id, name: a.name, size: a.size, uploadTo: n, data: l });
                    });
            }),
            d.readAsArrayBuffer(e);
    }
    function i(t, i) {
        if (!t) return this.emit("error", new Error("SocketIOFile requires Socket."));
        (this.instanceId = e()), (this.uploadId = 0), (this.ev = {}), (this.options = i || {}), (this.accepts = []), (this.maxFileSize = void 0), (this.socket = t), (this.uploadingFiles = {}), (this.isDestroyed = !1);
        var o = this;
        t.on("socket.io-file::recvSync", function (e) {
            (o.maxFileSize = e.maxFileSize || void 0), (o.accepts = e.accepts || []), (o.chunkSize = e.chunkSize || 10240), (o.transmissionDelay = e.transmissionDelay || 0), o.emit("ready");
        }),
            t.emit("socket.io-file::reqSync"),
            t.on("socket.io-file::disconnectByServer", function () {
                o.emit("disconnected"), o.destroy();
            });
    }
    var o = 0;
    if (
        ((i.prototype.getUploadId = function () {
            return "u_" + this.uploadId++;
        }),
        (i.prototype.upload = function (e, i) {
            if (this.isDestroyed) throw new Error("SocketIOFileClient is closed.");
            if (!e || (e.files && e.files.length <= 0) || e.length <= 0) return this.emit("error", new Error("No file(s) to upload.")), [];
            for (var o = this, s = [], r = e.files ? e.files : e, n = 0; n < r.length; n++) {
                var l = r[n],
                    a = this.getUploadId();
                s.push(a), (l.uploadId = a), t.call(o, l, i);
            }
            return s;
        }),
        (i.prototype.on = function (e, t) {
            if (this.isDestroyed) throw new Error("SocketIOFileClient is closed.");
            return this.ev[e] || (this.ev[e] = []), this.ev[e].push(t), this;
        }),
        (i.prototype.off = function (e, t) {
            if (this.isDestroyed) throw new Error("SocketIOFileClient is closed.");
            if (void 0 === e) this.ev = [];
            else if (void 0 === t) this.ev[e] && delete this.ev[e];
            else
                for (var i = this.ev[e] || [], o = 0; o < i.length; o++)
                    if (i[o] === t) {
                        i = i.splice(o, 1);
                        break;
                    }
            return this;
        }),
        (i.prototype.emit = function (e) {
            if (this.isDestroyed) throw new Error("SocketIOFileClient is closed.");
            var t = this.ev[e] || [],
                i = Array.from(arguments);
            i.splice(0, 1);
            for (var o = 0; o < t.length; o++) t[o].apply(null, i);
            return this;
        }),
        (i.prototype.abort = function (e) {
            if (this.isDestroyed) throw new Error("SocketIOFileClient is closed.");
            this.socket.emit("socket.io-file::abort::" + e);
        }),
        (i.prototype.destroy = function () {
            if (this.isDestroyed) throw new Error("SocketIOFileClient is closed.");
            var e = this.uploadingFiles;
            for (var t in e) this.abort(t);
            (this.socket = null), (this.uploadingFiles = null), (this.ev = null), (this.isDestroyed = !0);
        }),
        (i.prototype.getUploadInfo = function () {
            return JSON.parse(JSON.stringify(this.uploadingFiles));
        }),
        "object" == typeof exports && "undefined" != typeof module)
    )
        module.exports = i;
    else if ("function" == typeof define && define.amd) define(["SocketIOFileClient"], i);
    else {
        var s;
        "undefined" != typeof window ? (s = window) : "undefined" != typeof global ? (s = global) : "undefined" != typeof self && (s = self), (s.SocketIOFileClient = i);
    }
})();
//# sourceMappingURL=/sm/84b1ae11ebb49a840cc2a8fbee0cf6d9c3f573c5c3628e25f34c279e6b6d4b89.map